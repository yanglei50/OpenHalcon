//
// File generated by HDevelop for HALCON/.NET (C#) Version 17.12
//

using HalconDotNet;
using System;
using System.Windows.Forms;

public partial class HDevelopExport
{
    private HWindow halconWindow;

    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Image, ho_ROI_0, ho_ImageReduced;
    HObject ho_ImagePart, ho_GaussFilter1, ho_GaussFilter2;
    HObject ho_Filter, ho_ImageFFT = null, ho_ImageConvol = null;
    HObject ho_ImageFiltered = null, ho_ImageResult = null, ho_RegionDynThresh = null;
    HObject ho_ConnectedRegions = null, ho_SelectedRegions = null;
    HObject ho_RegionUnion = null, ho_RegionClosing = null, ho_ConnectedRegions1 = null;
    HObject ho_SelectedRegions1 = null, ho_ContCircle = null;

    // Local control variables 

    HTuple hv_Width = null, hv_Height = null, hv_WindowHandle = null;
    HTuple hov_Width = null, hov_Height= null;
    HTuple hv_Sigma1 = null, hv_Sigma2 = null, hv_NumImages = null;
    HTuple hv_Index = null, hv_Min = new HTuple(), hv_Max = new HTuple();
    HTuple hv_Range = new HTuple(), hv_Area = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Number = new HTuple(), hv_ResultMessage = new HTuple();
    HTuple hv_Color = new HTuple();
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
    public HDevelopExport()
    {
        // Default settings used in HDevelop 
        HOperatorSet.SetSystem("width", 512);
        HOperatorSet.SetSystem("height", 512);
        if (HalconAPI.isWindows)
            HOperatorSet.SetSystem("use_window_thread", "true");
        //action();
    }

    public HDevelopExport(HWindow halconWindow)
    {
        HOperatorSet.SetSystem("width", 512);
        HOperatorSet.SetSystem("height", 512);
        this.halconWindow = halconWindow;
        //hv_WindowHandle = halconWindow;
        HDevWindowStack.Push(halconWindow);
    }
#endif

    // Procedures 
    // External procedures 
    // Chapter: Develop
    // Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
    public void dev_update_off()
    {

        // Initialize local and output iconic variables 
        //This procedure sets different update settings to 'off'.
        //This is useful to get the best performance and reduce overhead.
        //
        // dev_update_pc(...); only in hdevelop
        // dev_update_var(...); only in hdevelop
        // dev_update_window(...); only in hdevelop

        return;
    }

    // Chapter: Graphics / Text
    // Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
    public void disp_continue_message(HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_GenParamName = null, hv_GenParamValue = null;
        HTuple hv_ContinueMessage = null;
        HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();

        // Initialize local and output iconic variables 
        //This procedure displays 'Press Run (F5) to continue' in the
        //lower right corner of the screen.
        //It uses the procedure disp_message.
        //
        //Input parameters:
        //WindowHandle: The window, where the text shall be displayed
        //Color: defines the text color.
        //   If set to '' or 'auto', the currently set color is used.
        //Box: If set to 'true', the text is displayed in a box.
        //
        //Convert the parameter Box to generic parameters.
        hv_GenParamName = new HTuple();
        hv_GenParamValue = new HTuple();
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
            {
                //Display no box
                hv_GenParamName = hv_GenParamName.TupleConcat("box");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual("true"))) != 0)
            {
                //Set a color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(0));
            }
        }
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
            {
                //Display no shadow.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual("true"))) != 0)
            {
                //Set a shadow color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(1));
            }
        }
        //
        if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
        {
            //disp_text does not accept an empty string for Color.
            hv_Color_COPY_INP_TMP = new HTuple();
        }
        //
        //Display the message.
        hv_ContinueMessage = "Press Run (F5) to continue";
        HOperatorSet.DispText(hv_WindowHandle, hv_ContinueMessage, "window", "bottom",
            "right", hv_Color_COPY_INP_TMP, hv_GenParamName, hv_GenParamValue);

        return;
    }

    // Chapter: Graphics / Text
    // Short Description: This procedure writes a text message. 
    public void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
        HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_GenParamName = null, hv_GenParamValue = null;
        HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
        HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
        HTuple hv_CoordSystem_COPY_INP_TMP = hv_CoordSystem.Clone();
        HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();

        // Initialize local and output iconic variables 
        //This procedure displays text in a graphics window.
        //
        //Input parameters:
        //WindowHandle: The WindowHandle of the graphics window, where
        //   the message should be displayed
        //String: A tuple of strings containing the text message to be displayed
        //CoordSystem: If set to 'window', the text position is given
        //   with respect to the window coordinate system.
        //   If set to 'image', image coordinates are used.
        //   (This may be useful in zoomed images.)
        //Row: The row coordinate of the desired text position
        //   A tuple of values is allowed to display text at different
        //   positions.
        //Column: The column coordinate of the desired text position
        //   A tuple of values is allowed to display text at different
        //   positions.
        //Color: defines the color of the text as string.
        //   If set to [], '' or 'auto' the currently set color is used.
        //   If a tuple of strings is passed, the colors are used cyclically...
        //   - if |Row| == |Column| == 1: for each new textline
        //   = else for each text position.
        //Box: If Box[0] is set to 'true', the text is written within an orange box.
        //     If set to' false', no box is displayed.
        //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
        //       the text is written in a box of that color.
        //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
        //       'true' -> display a shadow in a default color
        //       'false' -> display no shadow
        //       otherwise -> use given string as color string for the shadow color
        //
        //It is possible to display multiple text strings in a single call.
        //In this case, some restrictions apply:
        //- Multiple text positions can be defined by specifying a tuple
        //  with multiple Row and/or Column coordinates, i.e.:
        //  - |Row| == n, |Column| == n
        //  - |Row| == n, |Column| == 1
        //  - |Row| == 1, |Column| == n
        //- If |Row| == |Column| == 1,
        //  each element of String is display in a new textline.
        //- If multiple positions or specified, the number of Strings
        //  must match the number of positions, i.e.:
        //  - Either |String| == n (each string is displayed at the
        //                          corresponding position),
        //  - or     |String| == 1 (The string is displayed n times).
        //
        //
        //Convert the parameters for disp_text.
        if ((int)((new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
            new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
        {

            return;
        }
        if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Row_COPY_INP_TMP = 12;
        }
        if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Column_COPY_INP_TMP = 12;
        }
        //
        //Convert the parameter Box to generic parameters.
        hv_GenParamName = new HTuple();
        hv_GenParamValue = new HTuple();
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
            {
                //Display no box
                hv_GenParamName = hv_GenParamName.TupleConcat("box");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual("true"))) != 0)
            {
                //Set a color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(0));
            }
        }
        if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
        {
            if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
            {
                //Display no shadow.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
                hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
            }
            else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual("true"))) != 0)
            {
                //Set a shadow color other than the default.
                hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
                hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(1));
            }
        }
        //Restore default CoordSystem behavior.
        if ((int)(new HTuple(hv_CoordSystem_COPY_INP_TMP.TupleNotEqual("window"))) != 0)
        {
            hv_CoordSystem_COPY_INP_TMP = "image";
        }
        //
        if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
        {
            //disp_text does not accept an empty string for Color.
            hv_Color_COPY_INP_TMP = new HTuple();
        }
        //
        HOperatorSet.DispText(hv_WindowHandle, hv_String, hv_CoordSystem_COPY_INP_TMP,
            hv_Row_COPY_INP_TMP, hv_Column_COPY_INP_TMP, hv_Color_COPY_INP_TMP, hv_GenParamName,
            hv_GenParamValue);

        return;
    }

    // Chapter: Graphics / Text
    // Short Description: Set font independent of OS 
    public void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font,
        HTuple hv_Bold, HTuple hv_Slant)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_OS = null, hv_Fonts = new HTuple();
        HTuple hv_Style = null, hv_Exception = new HTuple(), hv_AvailableFonts = null;
        HTuple hv_Fdx = null, hv_Indices = new HTuple();
        HTuple hv_Font_COPY_INP_TMP = hv_Font.Clone();
        HTuple hv_Size_COPY_INP_TMP = hv_Size.Clone();

        // Initialize local and output iconic variables 
        //This procedure sets the text font of the current window with
        //the specified attributes.
        //
        //Input parameters:
        //WindowHandle: The graphics window for which the font will be set
        //Size: The font size. If Size=-1, the default of 16 is used.
        //Bold: If set to 'true', a bold font is used
        //Slant: If set to 'true', a slanted font is used
        //
        HOperatorSet.GetSystem("operating_system", out hv_OS);
        // dev_get_preferences(...); only in hdevelop
        // dev_set_preferences(...); only in hdevelop
        if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
            new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
        {
            hv_Size_COPY_INP_TMP = 16;
        }
        if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
        {
            //Restore previous behaviour
            hv_Size_COPY_INP_TMP = ((1.13677 * hv_Size_COPY_INP_TMP)).TupleInt();
        }
        else
        {
            hv_Size_COPY_INP_TMP = hv_Size_COPY_INP_TMP.TupleInt();
        }
        if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
        {
            hv_Fonts = new HTuple();
            hv_Fonts[0] = "Courier";
            hv_Fonts[1] = "Courier 10 Pitch";
            hv_Fonts[2] = "Courier New";
            hv_Fonts[3] = "CourierNew";
            hv_Fonts[4] = "Liberation Mono";
        }
        else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
        {
            hv_Fonts = new HTuple();
            hv_Fonts[0] = "Consolas";
            hv_Fonts[1] = "Menlo";
            hv_Fonts[2] = "Courier";
            hv_Fonts[3] = "Courier 10 Pitch";
            hv_Fonts[4] = "FreeMono";
            hv_Fonts[5] = "Liberation Mono";
        }
        else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
        {
            hv_Fonts = new HTuple();
            hv_Fonts[0] = "Luxi Sans";
            hv_Fonts[1] = "DejaVu Sans";
            hv_Fonts[2] = "FreeSans";
            hv_Fonts[3] = "Arial";
            hv_Fonts[4] = "Liberation Sans";
        }
        else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
        {
            hv_Fonts = new HTuple();
            hv_Fonts[0] = "Times New Roman";
            hv_Fonts[1] = "Luxi Serif";
            hv_Fonts[2] = "DejaVu Serif";
            hv_Fonts[3] = "FreeSerif";
            hv_Fonts[4] = "Utopia";
            hv_Fonts[5] = "Liberation Serif";
        }
        else
        {
            hv_Fonts = hv_Font_COPY_INP_TMP.Clone();
        }
        hv_Style = "";
        if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
        {
            hv_Style = hv_Style + "Bold";
        }
        else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
        {
            hv_Exception = "Wrong value of control parameter Bold";
            throw new HalconException(hv_Exception);
        }
        if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
        {
            hv_Style = hv_Style + "Italic";
        }
        else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
        {
            hv_Exception = "Wrong value of control parameter Slant";
            throw new HalconException(hv_Exception);
        }
        if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
        {
            hv_Style = "Normal";
        }
        HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
        hv_Font_COPY_INP_TMP = "";
        for (hv_Fdx = 0; (int)hv_Fdx <= (int)((new HTuple(hv_Fonts.TupleLength())) - 1); hv_Fdx = (int)hv_Fdx + 1)
        {
            hv_Indices = hv_AvailableFonts.TupleFind(hv_Fonts.TupleSelect(hv_Fdx));
            if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(0))) != 0)
            {
                if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
                {
                    hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(hv_Fdx);
                    break;
                }
            }
        }
        if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
        {
            throw new HalconException("Wrong value of control parameter Font");
        }
        hv_Font_COPY_INP_TMP = (((hv_Font_COPY_INP_TMP + "-") + hv_Style) + "-") + hv_Size_COPY_INP_TMP;
        HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);
        // dev_set_preferences(...); only in hdevelop

        return;
    }

#if !NO_EXPORT_MAIN
    // Main procedure 
    public void action_load(HWindowControl hWindowControl1, string ImagePath)
    {
        HObject ho_Image;
        OpenFileDialog openFileDialog1 = new OpenFileDialog();
        HTuple hv_Width = null, hv_Height = null, hv_WindowHandle = null;

        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        HOperatorSet.GenEmptyObj(out ho_Image);
       // ho_Image.Dispose();
        //DisposeAllObj();
        initaVariables();
        //对话框设置            
        //        string ImagePath;
        //        openFileDialog1.Filter = "JPEG文件|*.jpg|BMP文件|*.bmp|png文件|*.png";
        //        if (openFileDialog1.ShowDialog() == DialogResult.OK)
        //        {
        //将打开的文件名赋给ImagePath字符串变量                               
        //            ImagePath = openFileDialog1.FileName;
        HOperatorSet.ReadImage(out ho_Image, ImagePath);
//        }
        //打开窗口，将显示图片控件的句柄赋给窗口句柄，使窗口在控件中打开，并设置窗口宽高为显示图片控件的宽高            
        HOperatorSet.OpenWindow(0, 0, hWindowControl1.Width, hWindowControl1.Height, hWindowControl1.HalconWindow, "", "", out hv_WindowHandle);
        //HDevWindowStack.Push(hv_WindowHandle);

        //if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.DispObj(ho_Image, hv_WindowHandle);// HDevWindowStack.GetActive());
        }
        ho_Image.Dispose();
        hWindowControl1.Invalidate();
        hWindowControl1.Refresh();
        hWindowControl1.Update(); 
    }
    public void initaVariables()
    {
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Image);
        HOperatorSet.GenEmptyObj(out ho_ROI_0);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_ImagePart);
        HOperatorSet.GenEmptyObj(out ho_GaussFilter1);
        HOperatorSet.GenEmptyObj(out ho_GaussFilter2);
        HOperatorSet.GenEmptyObj(out ho_Filter);
        HOperatorSet.GenEmptyObj(out ho_ImageFFT);
        HOperatorSet.GenEmptyObj(out ho_ImageConvol);
        HOperatorSet.GenEmptyObj(out ho_ImageFiltered);
        HOperatorSet.GenEmptyObj(out ho_ImageResult);
        HOperatorSet.GenEmptyObj(out ho_RegionDynThresh);
        HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
        HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
        HOperatorSet.GenEmptyObj(out ho_RegionUnion);
        HOperatorSet.GenEmptyObj(out ho_RegionClosing);
        HOperatorSet.GenEmptyObj(out ho_ConnectedRegions1);
        HOperatorSet.GenEmptyObj(out ho_SelectedRegions1);
        HOperatorSet.GenEmptyObj(out ho_ContCircle);
    }
    public void action(HWindowControl hWindowControl1,String FilePath, String filename,String index)
    {
        initaVariables();
        try
        {
            //This program demonstrates how to detect small texture
            //defects on the surface of plastic items by using the fast
            //fourier transform (FFT).
            //First, we construct a suitable filter using Gaussian
            //filters. Then, the images and the filter are convolved
            //by using fast fourier transforms. Finally, the defects
            //are detected in the filtered images by using
            //morphology operators.
            //
            //Initializations
            dev_update_off();
            /*if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.CloseWindow(HDevWindowStack.Pop());
            }  LEI */

            //read image from file
            ho_Image.Dispose();

            //1.read image
            HOperatorSet.ReadImage(out ho_Image, FilePath +index);// "metal/tube_01");

//            ho_ROI_0.Dispose();
 //           HOperatorSet.GenRectangle1(out ho_ROI_0, 3.33632, 300.556, 990.549, 1648.14);
            ho_ROI_0.Dispose();
            HOperatorSet.GetImageSize(ho_Image, out hov_Width, out hov_Height);
            HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 0, 1200, 4096);//metal
            //HOperatorSet.GenRectangle1(out ho_ROI_0, 0, 620.059, 1998.27, 3603.45);//tube的
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
            //get_domain (ImageReduced, Domain)
            ho_ImagePart.Dispose();
            HOperatorSet.CropDomain(ho_ImageReduced, out ho_ImagePart);

            HOperatorSet.GetImageSize(ho_ImagePart, out hv_Width, out hv_Height);
            HOperatorSet.SetWindowAttr("background_color", "black");
            //HOperatorSet.OpenWindow(0, 0, hv_Width, hv_Height, 0, "visible", "", out hv_WindowHandle);
            //HDevWindowStack.Push(hv_WindowHandle);

            HOperatorSet.OpenWindow(0, 0, hWindowControl1.Width, hWindowControl1.Height, hWindowControl1.HalconWindow, "", "", out hv_WindowHandle);
            HDevWindowStack.Push(hv_WindowHandle);

            if (HDevWindowStack.IsOpen()) { HOperatorSet.DispObj(ho_ImagePart, HDevWindowStack.GetActive()); }
            ho_ImagePart.Dispose();
            hWindowControl1.Refresh();

            set_display_font(hv_WindowHandle, 14, "mono", "true", "false");
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 3);
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetColor(HDevWindowStack.GetActive(), "red");
            }
            //
            //Optimize the fft speed for the specific image size
            HOperatorSet.OptimizeRftSpeed(hv_Width, hv_Height, "standard");
            //
            //Construct a suitable filter by combining two gaussian
            //filters
            hv_Sigma1 = 10.0;
            hv_Sigma2 = 3.0;
            ho_GaussFilter1.Dispose();
            HOperatorSet.GenGaussFilter(out ho_GaussFilter1, hv_Sigma1, hv_Sigma1, 0.0,
                "none", "rft", hv_Width, hv_Height);
            ho_GaussFilter2.Dispose();
            HOperatorSet.GenGaussFilter(out ho_GaussFilter2, hv_Sigma2, hv_Sigma2, 0.0,
                "none", "rft", hv_Width, hv_Height);
            ho_Filter.Dispose();
            HOperatorSet.SubImage(ho_GaussFilter1, ho_GaussFilter2, out ho_Filter, 1, 0);
            //
            //Process the images iteratively
            hv_NumImages = 5;
            HTuple end_val34 = hv_NumImages;
            HTuple step_val34 = 1;
            //for (hv_Index = 1; hv_Index.Continue(end_val34, step_val34); hv_Index = hv_Index.TupleAdd(step_val34))
            //{
                HandleOneImage(FilePath, index);
            //}
        }
        catch (HalconException HDevExpDefaultException)
        {
            System.Diagnostics.Debug.WriteLine(HDevExpDefaultException.GetErrorMessage());
            Console.WriteLine(HDevExpDefaultException.StackTrace);
            //System.Diagnostics.Debug.Assert(false, HDevExpDefaultException.GetErrorMessage());
            DisposeAllObj();

            // throw HDevExpDefaultException;
        }

        DisposeAllObj();

    }

    private void DisposeAllObj()
    {
        ho_Image.Dispose();
        ho_ROI_0.Dispose();
        ho_ImageReduced.Dispose();
        ho_ImagePart.Dispose();
        ho_GaussFilter1.Dispose();
        ho_GaussFilter2.Dispose();
        ho_Filter.Dispose();
        ho_ImageFFT.Dispose();
        ho_ImageConvol.Dispose();
        ho_ImageFiltered.Dispose();
        ho_ImageResult.Dispose();
        ho_RegionDynThresh.Dispose();
        ho_ConnectedRegions.Dispose();
        ho_SelectedRegions.Dispose();
        ho_RegionUnion.Dispose();
        ho_RegionClosing.Dispose();
        ho_ConnectedRegions1.Dispose();
        ho_SelectedRegions1.Dispose();
        ho_ContCircle.Dispose();
    }

    private void HandleOneImage(string FilePath,string indexnum)
    {
        //
        //Read an image and convert it to gray values
        ho_Image.Dispose();
        HOperatorSet.ReadImage(out ho_Image, FilePath + indexnum);
        {
            HObject ExpTmpOutVar_0;
            HOperatorSet.Rgb1ToGray(ho_Image, out ExpTmpOutVar_0);
            ho_Image.Dispose();
            ho_Image = ExpTmpOutVar_0;
        }
        //gen_rectangle1 (ROI_0, 3.33632, 300.556, 990.549, 1648.14)
        ho_ImageReduced.Dispose();
        ho_ImagePart.Dispose();

        HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
        //get_domain (ImageReduced, Domain)
        ho_ImagePart.Dispose();
        HOperatorSet.CropDomain(ho_ImageReduced, out ho_ImagePart);

        //Perform the convolution in the frequency domain
        ho_ImageFFT.Dispose();
        HOperatorSet.RftGeneric(ho_ImagePart, out ho_ImageFFT, "to_freq", "none", "complex",
            hv_Width);
        ho_ImageConvol.Dispose();
        HOperatorSet.ConvolFft(ho_ImageFFT, ho_Filter, out ho_ImageConvol);
        ho_ImageFiltered.Dispose();
        HOperatorSet.RftGeneric(ho_ImageConvol, out ho_ImageFiltered, "from_freq",
            "n", "real", hv_Width);
        //
        //Process the filtered image
        ho_ImageResult.Dispose();
        HOperatorSet.GrayRangeRect(ho_ImageFiltered, out ho_ImageResult, 10, 10);
        HOperatorSet.MinMaxGray(ho_ImageResult, ho_ImageResult, 0, out hv_Min, out hv_Max,
            out hv_Range);
        ho_RegionDynThresh.Dispose();
        HOperatorSet.Threshold(ho_ImageResult, out ho_RegionDynThresh, (((new HTuple(5.55)).TupleConcat(
            hv_Max * 0.8))).TupleMax(), 255);
        ho_ConnectedRegions.Dispose();
        HOperatorSet.Connection(ho_RegionDynThresh, out ho_ConnectedRegions);
        ho_SelectedRegions.Dispose();
        HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions, "area",
            "and", 4, 99999);
        ho_RegionUnion.Dispose();
        HOperatorSet.Union1(ho_SelectedRegions, out ho_RegionUnion);
        ho_RegionClosing.Dispose();
        HOperatorSet.ClosingCircle(ho_RegionUnion, out ho_RegionClosing, 10);
        ho_ConnectedRegions1.Dispose();
        HOperatorSet.Connection(ho_RegionClosing, out ho_ConnectedRegions1);
        ho_SelectedRegions1.Dispose();
        HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions1, "area",
            "and", 10, 99999);
        HOperatorSet.AreaCenter(ho_SelectedRegions1, out hv_Area, out hv_Row, out hv_Column);
        //
        //Display the results
        //lei
        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.DispObj(ho_ImagePart, HDevWindowStack.GetActive());
        }
        hv_Number = new HTuple(hv_Area.TupleLength());
        if ((int)(hv_Number) != 0)
        {
            ho_ContCircle.Dispose();
            HOperatorSet.GenCircleContourXld(out ho_ContCircle, hv_Row, hv_Column,
                HTuple.TupleGenConst(hv_Number, 30), HTuple.TupleGenConst(hv_Number,
                0), HTuple.TupleGenConst(hv_Number, (new HTuple(360)).TupleRad()), "positive",
                1);
            hv_ResultMessage = new HTuple();
            hv_ResultMessage[0] = "Not OK";
            hv_ResultMessage = hv_ResultMessage.TupleConcat(hv_Number + " defect(s) found");
            hv_Color = new HTuple();
            hv_Color[0] = "red";
            hv_Color[1] = "black";
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_ContCircle, HDevWindowStack.GetActive());
                //HOperatorSet.DispObj(ho_ContCircle, this.halconWindow);//
            }
        }
        else
        {
            hv_ResultMessage = "OK";
            hv_Color = "forest green";
        }
        /*disp_message(this.halconWindow, hv_ResultMessage, "window", 12, 12, hv_Color,
            "true");*/
        disp_message(hv_WindowHandle, hv_ResultMessage, "window", 12, 12, hv_Color, "true");
        //if ((int)(new HTuple(hv_Index.TupleNotEqual(hv_NumImages))) != 0)
        //{
        //    disp_continue_message(hv_WindowHandle, "black", "true");
        //    // stop(...); only in hdevelop
        //}
    }

#endif


}
//#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
//public class HDevelopExportApp
//{
//    static void Main(string[] args)
//    {
//        new HDevelopExport();
//    }
//}
//#endif

